### 关于hashCode和equals的处理，遵循如下规则：

------

1. 只要重写equals，就必须重写hashCode。

2. 因为Set存储的是不重复的对象，依据hashCode和equals进行判断，所以Set存储的对相关必须重写这个两个方法。

3. 如果自定义对象作为Map的键，那么必须重写hashCode和equals。

   说明：String重写了hashCode和equals方法，所以我们可以非常愉快地使用String对象作为key来使用。

### 介绍

1. Equals()的作用是用来判断两个对线是否相等。
2. hashCode() 的作用是获取哈希码，也称为散列码；它实际上是返回一个int整数，这个哈希码的作用是确定该对象在哈希表中的索引关系。

### 关系

​	__我们以“类的用途”来将“hashCode()和equals()的关系”分两种情况来说明。__

1. 不会创建“类对应的散列表”

   这里所说的“不会创建类对应的散列表”是说：我们不会在HashSet, Hashtable, HashMap等等这些本质是散列表的数据结构中，用到该类。例如，不会创建该类的HashSet集合。

   在这种情况下，该类的“hashCode() 和 equals() ”没有半毛钱关系的！equals() 用来比较该类的两个对象是否相等。而hashCode() 则根本没有任何作用。

2. 会创建“类对应的散列表”

   这里所说的“会创建类对应的散列表”是说：我们会在HashSet，Hashtable，HashMap等等这些本质是散列表的数据结构中，用到该类。例如，会创建该类的HashSet集合。

   在这种情况下，该类的“hashCode()和equals()”是有关系的：

   - __如果两个对象相等，那么它们的hashCode()值一定相等。这里的相等是指，通过equals()比较两个对象时返回true。__
   - __如果两个对象hashCode()相等，它们并不一定相等。因为在散列表中,hashCode相等，即两个键值对的哈希值相等。然而哈希值相等，不一定能得出键值对相等。补充说一句：“两个不同的键值对，哈希值相等”，这就是哈希冲突。__

------

### 举例说明

先解释下什么叫“类对应的散列表”。

> 散列表（Hash table，也叫哈希表），是根据关键码值(Key value)而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。这个映射函数叫做散列函数，存放记录的数组叫做散列表。
> 给定表M，存在函数f(key)，对任意给定的关键字值key，代入函数后若能得到包含该关键字的记录在表中的地址，则称表M为哈希(Hash）表，函数f(key)为哈希(Hash) 函数。
